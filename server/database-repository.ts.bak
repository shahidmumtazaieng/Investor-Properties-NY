  // ==================== PARTNERS ====================
  async getAllPartners() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock partners data');
      return [];
    }
    return await db.select().from(schema.partners)
      .where(eq(schema.partners.isActive, true));
  }

  async getPartnerById(id: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock partner data');
      return null;
    }
    const result = await db.select().from(schema.partners).where(eq(schema.partners.id, id));
    return result[0] || null;
  }

  async getPartnerByUsername(username: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock partner data for username:', username);
      return null;
    }
    const result = await db.select().from(schema.partners).where(eq(schema.partners.username, username));
    return result[0] || null;
  }

  async createPartner(partnerData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating partner');
      return { id: 'demo-partner-id', ...partnerData };
    }
    const result = await db!.insert(schema.partners).values(partnerData).returning();
    return result[0];
  }

  async updatePartner(id: string, partnerData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating partner');
      return { id, ...partnerData };
    }
    const result = await db!.update(schema.partners)
      .set({ ...partnerData, updatedAt: new Date() })
      .where(eq(schema.partners.id, id))
      .returning();
    return result[0];
  }

  // ==================== COMMON INVESTORS ====================
  async getAllCommonInvestors() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investors data');
      return [];
    }
    return await db.select().from(schema.commonInvestors)
      .where(eq(schema.commonInvestors.isActive, true));
  }

  async getCommonInvestorById(id: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investor data');
      return null;
    }
    const result = await db.select().from(schema.commonInvestors).where(eq(schema.commonInvestors.id, id));
    return result[0] || null;
  }

  async getCommonInvestorByUsername(username: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investor data for username:', username);
      return null;
    }
    const result = await db.select().from(schema.commonInvestors).where(eq(schema.commonInvestors.username, username));
    return result[0] || null;
  }

  async createCommonInvestor(investorData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating common investor');
      return { id: 'demo-common-investor-id', ...investorData };
    }
    const result = await db!.insert(schema.commonInvestors).values(investorData).returning();
    return result[0];
  }

  async updateCommonInvestor(id: string, investorData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating common investor');
      return { id, ...investorData };
    }
    const result = await db!.update(schema.commonInvestors)
      .set({ ...investorData, updatedAt: new Date() })
      .where(eq(schema.commonInvestors.id, id))
      .returning();
    return result[0];
  }

  async getCommonInvestorsWithForeclosureSubscription() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investors with foreclosure subscription');
      return [];
    }
    return await db.select().from(schema.commonInvestors)
      .where(
        and(
          eq(schema.commonInvestors.isActive, true),
          eq(schema.commonInvestors.hasForeclosureSubscription, true),
          gte(schema.commonInvestors.foreclosureSubscriptionExpiry, new Date())
        )
      );
  }

  // ==================== INSTITUTIONAL INVESTORS ====================
  async getAllInstitutionalInvestors() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock institutional investors data');
      return [];
    }
    return await db.select().from(schema.institutionalInvestors)
      .where(eq(schema.institutionalInvestors.isActive, true));
  }

  async getInstitutionalInvestorById(id: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock institutional investor data');
      return null;
    }
    const result = await db.select().from(schema.institutionalInvestors)
      .where(eq(schema.institutionalInvestors.id, id));
    return result[0] || null;
  }

  async getInstitutionalInvestorByUsername(username: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock institutional investor data for username:', username);
      return null;
    }
    const result = await db.select().from(schema.institutionalInvestors)
      .where(eq(schema.institutionalInvestors.username, username));
    return result[0] || null;
  }

  async createInstitutionalInvestor(investorData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating institutional investor');
      return { id: 'demo-institutional-investor-id', ...investorData };
    }
    const result = await db!.insert(schema.institutionalInvestors).values(investorData).returning();
    return result[0];
  }

  async updateInstitutionalInvestor(id: string, investorData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating institutional investor');
      return { id, ...investorData };
    }
    const result = await db!.update(schema.institutionalInvestors)
      .set({ ...investorData, updatedAt: new Date() })
      .where(eq(schema.institutionalInvestors.id, id))
      .returning();
    return result[0];
  }

  // ==================== FORECLOSURE LISTINGS ====================
  async getAllForeclosureListings() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock foreclosure listings data');
      return [
        {
          id: "f1",
          address: "789 Bronx Ave",
          county: "Bronx",
          auctionDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days from now
          startingBid: "450000",
          propertyType: "Multi-Family",
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        },
        {
          id: "f2",
          address: "321 Staten Island Way",
          county: "Richmond",
          auctionDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(), // 14 days from now
          startingBid: "380000",
          propertyType: "Single Family",
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];
    }
    return await db.select().from(schema.foreclosureListings)
      .where(eq(schema.foreclosureListings.isActive, true))
      .orderBy(desc(schema.foreclosureListings.createdAt));
  }

  async getForeclosureListingById(id: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock foreclosure listing data for id:', id);
      return null;
    }
    const result = await db.select().from(schema.foreclosureListings)
      .where(eq(schema.foreclosureListings.id, id));
    return result[0] || null;
  }

  async createForeclosureListing(listingData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating foreclosure listing');
      return { id: 'demo-foreclosure-listing-id', ...listingData };
    }
    const result = await db!.insert(schema.foreclosureListings).values(listingData).returning();
    return result[0];
  }

  async updateForeclosureListing(id: string, listingData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating foreclosure listing');
      return { id, ...listingData };
    }
    const result = await db!.update(schema.foreclosureListings)
      .set({ ...listingData, updatedAt: new Date() })
      .where(eq(schema.foreclosureListings.id, id))
      .returning();
    return result[0];
  }

  // ==================== OFFERS ====================
  async getAllOffers() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock offers data');
      return [];
    }
    return await db.select().from(schema.offers)
      .orderBy(desc(schema.offers.createdAt));
  }

  async getOfferById(id: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock offer data');
      return null;
    }
    const result = await db.select().from(schema.offers).where(eq(schema.offers.id, id));
    return result[0] || null;
  }

  async getOffersByPropertyId(propertyId: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock offers data for propertyId:', propertyId);
      return [];
    }
    return await db.select().from(schema.offers)
      .where(eq(schema.offers.propertyId, propertyId))
      .orderBy(desc(schema.offers.createdAt));
  }

  async getOffersByBuyerId(buyerId: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock offers data for buyerId:', buyerId);
      return [];
    }
    return await db.select().from(schema.offers)
      .where(eq(schema.offers.buyerLeadId, buyerId))
      .orderBy(desc(schema.offers.createdAt));
  }

  async createOffer(offerData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating offer');
      return { id: 'demo-offer-id', ...offerData };
    }
    const result = await db!.insert(schema.offers).values(offerData).returning();
    return result[0];
  }

  async updateOffer(id: string, offerData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating offer');
      return { id, ...offerData };
    }
    const result = await db!.update(schema.offers)
      .set({ ...offerData, updatedAt: new Date() })
      .where(eq(schema.offers.id, id))
      .returning();
    return result[0];
  }

  // ==================== SUBSCRIPTIONS ====================
  async createSubscriptionRecord(investorId: string, subscriptionData: any) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating subscription record');
      return { id: 'demo-subscription-id', leadId: investorId, ...subscriptionData };
    }
    
    // Update the investor record
    await this.updateCommonInvestor(investorId, {
      hasForeclosureSubscription: true,
      foreclosureSubscriptionExpiry: subscriptionData.expiryDate,
      subscriptionPlan: subscriptionData.planType.toLowerCase()
    });
    
    // Store in foreclosure_subscriptions table
    const result = await db!.insert(schema.foreclosureSubscriptions).values({
      leadId: investorId,
      counties: ['ALL'], // Default to all counties
      subscriptionType: subscriptionData.planType,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();
    
    return result[0];
  }

  async updateSubscriptionStatus(investorId: string, isActive: boolean) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not updating subscription status');
      return { id: investorId };
    }
    
    // Update the investor record
    const result = await db!.update(schema.commonInvestors)
      .set({ 
        hasForeclosureSubscription: isActive,
        updatedAt: new Date()
      })
      .where(eq(schema.commonInvestors.id, investorId))
      .returning();
    
    // Also update any subscription records
    await db!.update(schema.foreclosureSubscriptions)
      .set({ 
        isActive: isActive,
        updatedAt: new Date()
      })
      .where(eq(schema.foreclosureSubscriptions.leadId, investorId));
    
    return result[0];
  }

  // ==================== AUTHENTICATION ====================
  
  // Common Investor Authentication
  async getCommonInvestorByEmail(email: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investor data for email:', email);
      return null;
    }
    const result = await db.select().from(schema.commonInvestors)
      .where(eq(schema.commonInvestors.email, email));
    return result[0] || null;
  }

  async authenticateCommonInvestor(username: string, password: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not authenticating common investor');
      // For demo purposes, return a mock user if username is 'demo'
      if (username === 'demo') {
        return {
          id: 'demo-user-id',
          username: 'demo',
          email: 'demo@example.com',
          firstName: 'Demo',
          lastName: 'User',
          userType: 'common_investor'
        };
      }
      return null;
    }

    const investor = await this.getCommonInvestorByUsername(username);
    if (!investor) {
      return null;
    }

    const isValid = await bcrypt.compare(password, investor.password);
    if (!isValid) {
      return null;
    }

    return investor;
  }

  // Institutional Investor Authentication
  async getInstitutionalInvestorByEmail(email: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock institutional investor data for email:', email);
      return null;
    }
    const result = await db.select().from(schema.institutionalInvestors)
      .where(eq(schema.institutionalInvestors.email, email));
    return result[0] || null;
  }

  async authenticateInstitutionalInvestor(username: string, password: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not authenticating institutional investor');
      return null;
    }

    const investor = await this.getInstitutionalInvestorByUsername(username);
    if (!investor || !investor.password) {
      return null;
    }

    const isValid = await bcrypt.compare(password, investor.password);
    if (!isValid) {
      return null;
    }

    return investor;
  }

  // Partner Authentication
  async getPartnerByEmail(email: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock partner data for email:', email);
      return null;
    }
    const result = await db.select().from(schema.partners)
      .where(eq(schema.partners.email, email));
    return result[0] || null;
  }

  async authenticatePartner(username: string, password: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not authenticating partner');
      return null;
    }

    const partner = await this.getPartnerByUsername(username);
    if (!partner) {
      return null;
    }

    const isValid = await bcrypt.compare(password, partner.password);
    if (!isValid) {
      return null;
    }

    return partner;
  }

  // ==================== SESSION MANAGEMENT ====================
  
  // Common Investor Sessions
  async createCommonInvestorSession(investorId: string, sessionToken: string, expiresAt: Date) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating common investor session');
      return { id: 'demo-session-id', investorId, sessionToken, expiresAt, createdAt: new Date() };
    }
    const result = await db!.insert(schema.commonInvestorSessions).values({
      investorId,
      sessionToken,
      expiresAt,
      createdAt: new Date()
    }).returning();
    return result[0];
  }

  async getCommonInvestorSession(sessionToken: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock common investor session data');
      return null;
    }
    const result = await db.select().from(schema.commonInvestorSessions)
      .where(eq(schema.commonInvestorSessions.sessionToken, sessionToken));
    return result[0] || null;
  }

  async deleteCommonInvestorSession(sessionToken: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not deleting common investor session');
      return;
    }
    await db!.delete(schema.commonInvestorSessions)
      .where(eq(schema.commonInvestorSessions.sessionToken, sessionToken));
  }

  async cleanupExpiredSessions() {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not cleaning up expired sessions');
      return;
    }
    await db!.delete(schema.commonInvestorSessions)
      .where(gte(schema.commonInvestorSessions.expiresAt, new Date()));
  }

  // Institutional Investor Sessions
  async createInstitutionalSession(investorId: string, sessionToken: string, expiresAt: Date) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not creating institutional session');
      return { id: 'demo-institutional-session-id', investorId, sessionToken, expiresAt, createdAt: new Date() };
    }
    const result = await db!.insert(schema.institutionalSessions).values({
      investorId,
      sessionToken,
      expiresAt,
      createdAt: new Date()
    }).returning();
    return result[0];
  }

  async getInstitutionalSession(sessionToken: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock institutional session data');
      return null;
    }
    const result = await db.select().from(schema.institutionalSessions)
      .where(eq(schema.institutionalSessions.sessionToken, sessionToken));
    return result[0] || null;
  }

  async deleteInstitutionalSession(sessionToken: string) {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: not deleting institutional session');
      return;
    }
    await db!.delete(schema.institutionalSessions)
      .where(eq(schema.institutionalSessions.sessionToken, sessionToken));
  }

  // ==================== UTILITY FUNCTIONS ====================
  
  generateSessionToken(): string {
    return randomUUID() + '-' + Date.now();
  }

  generateEmailVerificationToken(): string {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }

  generatePhoneVerificationCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  async hashPassword(password: string): Promise<string> {
    // Handle demo mode
    if (!db) {
      console.log('Demo mode: returning mock hashed password');
      return password; // In demo mode, just return the password as-is
    }
    return await bcrypt.hash(password, 12);
  }